## Начальные сведения
* Виртуалке были даны 2 ядра (влиять это ни на что не должно, кроме заполнения базы) 
* Остальное все по умолчанию

## CPU

[profile-cpu.html](profile-cpu.html)

- RequestHandler.getEntries 1%. Очень быстрая работа dao. Возможно потому что все-таки данных в базе было мало. 
- StreamResponse.stream 89,69%. Метод работы с чанками и запись их в сессию (сокет).

В методе StreamResponse.stream большую часть занимает запись в сессию, и лишь малую часть на конвертацию данных
в массив байт:
- Integer.toHexString 2%;
- toByteArray 5%
- Session.write 76%.

Метод StreamResponse.processWrite 87% тут же и работа итератора.

## ALLOC

[profile-alloc.html](profile-alloc.html)

На профиле видны все аллокации, которые создаются при формировании чанков, а именно:
- Integer.toHexString при переводе длинны сообщения в строку;
- String.getBytes при переводе строки в массив байт;
- Session.write когда происходит запись в сессию;
- toArray при переводе MemorySegment в массив байт.

На профиле нет аллокации ByteBuffer. Но, как я понимаю, его и не должно быть.
Метод ByteBuffer.wrap() не выделяет новую память для хранения данных. 
Он создает новый объект ByteBuffer, который обертывает существующий массив байтов, 
переданный ему в качестве аргумента. 
Таким образом, данный метод не производит аллокацию памяти.

## LOCK

[profile-lock.html](profile-lock.html)

Интересно, что профиль блокировок получился пустым. 

## Выводы

- При нынешней реализации формируется большой блок данных, а не отправляется сразу (как я понимаю);
- Также при нынешней реализации существуют лишние аллокции, такие как Integer.toHexString, String.getBytes.

## Улучшения

- Возможно не переводить MemorySegment в массив байт, а работать сразу с ними;
- Ассинхронная запись данных в сокет.